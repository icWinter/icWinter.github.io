<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>扫雷</title>
</head>

<body>
    <br />
    <br />
    <div style="text-align:center">
        <canvas id="canvas">画布</canvas>
    </div>
</body>

</html>

<script>
    var canvas;
    var ctx;
    var lineWidth = 2;
    var mapSize = 700;
    var canvasSize = 700 + lineWidth;

    var cellArray = [];
    // var cellCount = 0;
    var step;
    var mineIndexArray = [];

    initCtx(canvasSize, 600);

    // 重新初始化一下画布
    function initCtx(side, r) {
        canvas = document.getElementById('canvas');
        //  计算画布的宽度
        var width = canvas.offsetWidth;
        //  计算画布的高度
        var height = canvas.offsetHeight;
        //  设置宽高
        canvas.width = side;
        canvas.height = side;
        ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, side, side);
        addEvent(canvas);
        inintMap(side);
    }

    // 绑定事件
    function addEvent(canvas) {
        canvas.addEventListener('click', function (e) {
            if (containPoint(e.offsetX, e.offsetY)) {
                var index = getCellPosition(e.offsetX, e.offsetY);
                if (cellArray[index].checked == 0) {
                    checkSquare(cellArray[index]);
                }
            } else {
                window.alert("请点击网格内部！");
            }
        })
    }

    // 初始化地图
    function inintMap(side) {
        ctx.fillStyle = "#11EEEE";
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillRect(0, 0, side, side);
        // ctx.lineWidth = 1;
        step = Math.floor((side - lineWidth) / 10) - lineWidth;
        // 通过for, 循环执行画线动作
        createCell(step, lineWidth, 10);
        // 初始化地雷
        initMine(10);
    }

    // 创建正方形棋盘格
    function createCell(step, lineWidth, num) {
        for (var i = 0; i < num; i++) {
            for (var j = 0; j < num; j++) {
                // 计算起始坐标
                var x = (1 + i) * lineWidth + i * step;
                var y = (1 + j) * lineWidth + j * step;
                cellArray[i * 10 + j] = new Cell(i * 10 + j, x, y, i, j);
                ctx.fillStyle = '#1A1AE6';
                ctx.beginPath();
                ctx.fillRect(cellArray[i * 10 + j].xPix, cellArray[i * 10 + j].yPix, step, step);
                // cellCount++;
            }
        }
    }

    // 返回位置的
    function getCellPosition(x, y) {
        var index = Math.floor(x / 68) * 10 + Math.floor(y / 68);
        return index;
    }

    // 画矩形
    function checkSquare(cell) {
        if(cell.checked !=0){
            return;
        }
        cell.checked=2;
        if (cell.mineSign == 1) {
            ctx.fillStyle = "#F14141";
            ctx.fillRect(cell.xPix, cell.yPix, step, step);
            ctx.fillStyle = "#060B0B";
            ctx.font = "48px serif";
            ctx.fillText("☠", cell.xPix + step / 8, cell.yPix + step / 1.25);
        } else if(cell.mineNum > 0){
            ctx.fillStyle = "#63D0D0";
            ctx.fillRect(cell.xPix, cell.yPix, step, step);
            ctx.fillStyle = "#060B0B";
            ctx.font = "48px serif";
            ctx.fillText(cell.mineNum, cell.xPix + step / 3.5, cell.yPix + step / 1.25);
        }else{
            // 扩展算法
            drawSquare(cell);
            var cellArr = getBorderCell(cell);
            for(var i = 0 ; i < cellArr.length ; i++){
                checkSquare(cellArr[i]);
            }
        }
    }

    // 画矩形
    function drawSquare(cell) {
        if (cell.mineSign == 1) {
            ctx.fillStyle = "#F14141";
            ctx.fillRect(cell.xPix, cell.yPix, step, step);
            ctx.fillStyle = "#060B0B";
            ctx.font = "48px serif";
            ctx.fillText("☠", cell.xPix + step / 8, cell.yPix + step / 1.25);
        } else {
            ctx.fillStyle = "#63D0D0";
            ctx.fillRect(cell.xPix, cell.yPix, step, step);
            ctx.fillStyle = "#060B0B";
            ctx.font = "48px serif";
            ctx.fillText(cell.mineNum, cell.xPix + step / 3.5, cell.yPix + step / 1.25);
        }

    }

    function containPoint(x, y) {
        if (x < 0 || x > mapSize || y < 0 || y > mapSize) {
            return false;
        }
        return true;
    }

    // 声明数据结构
    function Cell(index, xPix, yPix, x, y, mineNum) {
        // 单元格下标
        this.index = index;
        // 单元格左上角x坐标
        this.xPix = xPix;
        // 单元格左上角y坐标
        this.yPix = yPix;
        // 单元格x坐标
        this.x = x;
        // 单元格y坐标
        this.y = y;
        // 相邻单元格的地雷数量和
        this.mineNum = 0;
        // 地雷标记(0：没有地雷，1:有地雷)
        this.mineSign = 0;
        // 操作标记(0：待标记，1：地雷标记，2:已经公开)
        this.checked = 0;
    }

    // 初始化地雷
    function initMine(num) {
        for (var i = 0; i < num; i++) {
            var index = Math.ceil(Math.random() * 100);
            if (index == 0 || index == 100) {
                i--;
            } else {
                if (cellArray[index].mineSign == 1) {
                    i--;
                } else {
                    cellArray[index].mineSign = 1;
                    mineIndexArray[i] = index;
                }
            }
        }
        calculateMineNum();
    }

    // 计算周围地雷数量
    function calculateMineNum() {
        for (var i = 0; i < mineIndexArray.length; i++) {
            var cellArr = getBorderCell(cellArray[mineIndexArray[i]]);
            for (var j = 0; j < cellArr.length; j++) {
                mineCount = 0;
                var cArr = getBorderCell(cellArr[j]);
                for (var k = 0; k < cArr.length; k++) {
                    if (cArr[k].mineSign == 1) {
                        mineCount++;
                    }
                }
                cellArr[j].mineNum = mineCount;
            }
        }
    }

    // 获取相邻单元格
    function getBorderCell(cell) {
        var cellArr = [];
        var count = 0;
        for (var i = -1; i < 2; i++) {
            for (var j = -1; j < 2; j++) {
                if (cell.x + i < 0 || cell.y + j < 0 || cell.x + i > 9 || cell.y + j > 9) {
                    continue;
                }
                if (i == 0 && j == 0) {
                    continue;
                }
                cellArr[count] = cellArray[10 * (cell.x + i) + cell.y + j];
                count++;
            }
        }
        return cellArr;
    }

</script>